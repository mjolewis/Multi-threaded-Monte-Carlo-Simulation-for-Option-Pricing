//
// Random number generator. Currently, supports Mersenne Twister, Lagged Fibonacci, and Linear Congruential engines.
//
// Created by Michael Lewis on 9/10/23.
//

#include "Rng.hpp"

#include <iostream>
#include <utility>
#include <string>
#include <random>

#include "EngineType.hpp"

// Alias for universal function wrapper that will cache the random number generator
using RngFunction = std::function<double (void)>;

/**
 * Overloaded ctor. Provides flexibility to clients by allowing them to specify their own RNG. The provided RNG
 * and engine
 * @param _rng
 */
RNG::RNG(RngFunction  _rng) : rng{std::move(_rng)}
{

}

/**
 * Move ctor
 * @param other Another RNG whose members will be moved into this RNG
 */
RNG::RNG(RNG &&other) noexcept : rng{std::move(other.rng)}
{

}

/**
 * Assignment Operator
 * @param other Another RNG whose members will be deeply copied into this RNG
 * @return This RNG whose members have been initialized from the other RNG
 */
RNG& RNG::operator=(const RNG& other)
{
    if (this == &other) return *this;

    rng = other.rng;

    return *this;
}

/**
 * Assignment Operator
 * @param other Another RNG whose members will be deeply copied into this RNG
 * @return This RNG whose members have been moved from the other RNG
 */
RNG& RNG::operator=(RNG&& other) noexcept
{
    if (this == &other) return *this;

    rng = std::move(other.rng);

    return *this;
}

/**
 * Generates a single random variate bounded by n[0,1]. The Mersenne Twister engine is
 * seeded by a Random Device and bound.
 * @return The random variate generated by the Mersenne Twister engine
 */
double RNG::mersenneTwisterEngine()
{
    static thread_local std::random_device rd;                     // Choose the seed
    static thread_local std::mt19937_64 engine(rd());              // Choose the engine and seed it with the rd
    static thread_local std::normal_distribution<> n(0, 1);        // Choose the distribution
    return n(engine);                                              // Generate the random variate
}

/**
 * Generates a single random variate bounded by n[0,1]. The Lagged Fibonacci engine is
 * seeded with system clock.
 * @return The random variate generated by the Lagged Fibonacci engine
 */
double RNG::laggedFibonacciEngine()
{
    // Choose the seed
    static thread_local unsigned int seed = std::chrono::system_clock::now().time_since_epoch().count();

    // Choose the engine and seed it
    static thread_local std::subtract_with_carry_engine<unsigned,24,10,24> engine(seed);

    // Choose the distribution
    static thread_local std::normal_distribution<> n(0, 1);

    // Generate the random variate
    return n(engine);
}

/**
 * Generates a single random variate bounded by n[0,1]. The Linear Congruential engine is
 * seeded with system clock.
 * @return The random variate generated by the Linear Congruential engine
 */
double RNG::linearCongruentialEngine()
{
    // Choose the seed
    static thread_local unsigned int seed = std::chrono::system_clock::now().time_since_epoch().count();

    // Choose the engine and seed it
    static thread_local std::linear_congruential_engine<unsigned,23,10,24> engine(seed);

    // Choose the distribution
    static thread_local std::normal_distribution<> n(0, 1);

    // Generate the random variate
    return n(engine);
}

/**
 * Allows clients to select the type of engine by exposing a console interface.
 * @return A std::pair containing a Gaussian Random Number Generator packaged into a
 * universal function wrapper along with a description of the engine used to generate the variate.
 */
std::pair<RngFunction, std::string> RNG::buildEngine()
{

    unsigned int engineId;
    EngineType engineType = EngineType::UNKNOWN;
    while (engineType == EngineType::UNKNOWN || std::cin.fail())
    {
        // Reset the fail bit and clear the buffer when user provided input can't be converted to the correct type
        if(std::cin.fail())
        {
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }

        // Set of currently supported engines, which can be extended in the future should requirements demand it
        std::cout << "Select the Engine" << std::endl;
        std::cout << "1 - Mersenne Twister" << std::endl;
        std::cout << "2 - Lagged Fibonacci" << std::endl;
        std::cout << "3 - Linear Congruential" << std::endl;

        std::cin >> engineId;
        engineType = EngineType::getEngineById(engineId);
    }

    // Provide the client a callable engine by wrapping it in a universal function
    if (engineType == EngineType::LAGGED_FIBONACCI)
    {
        rng = [] { return laggedFibonacciEngine(); };
    }
    if (engineType == EngineType::LINEAR_CONGRUENTIAL)
    {
        rng = [] { return linearCongruentialEngine(); };
    }
    else
    {
        // Default option
        rng = [] { return mersenneTwisterEngine(); };
    }

    return {rng, engineType.getDesc()};
}
